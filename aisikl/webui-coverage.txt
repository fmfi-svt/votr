
- IRRELEVANT = we definitely don't need it (e.g. only used for browser layout)
- UNSUPPORTED = rarely used by AIS so we ignore it until we need it
- PARTIAL = mostly done, but some parts of the original webui code are still
  missing (and marked TODO) without being declared irrelevant/unsupported
- COMPLETE = everything from webui is either in votr or never will be



# browserDetect

IRRELEVANT



# cmn_*

IRRELEVANT



# ComponentFactory

COMPLETE (removed)

In AIS, each "component" consists of two objects: the actual DOM node, and an
`JSObject` that is created when it's needed. Current state is stored in DOM
attributes. Votr creates all components in `Dialog._init()`, and only uses DOM
nodes for initial parsing.

A component can be accessed with `my_dialog.components['compName']` or simply
`my_dialog.compName`.

- getComponent(), initJSO(), initJSObject(), ensureJSOBase(), ensureJSO(),
  ensureJSObject(), getEnsuredJSOById()
    - IRRELEVANT, see above.
    - The mapping between jsct and class is in `aisikl/components/__init__.py`.
    - The distinction between getComponent() and initJSO() is unclear, but it
      probably doesn't matter.
- getMasterComponent()
    - Replace with `element.find_parent(jsct=True)`.
- hbe(), h(), on*()
    - When a DOM event of a given type comes, webui calls the corresponding
      method. IRRELEVANT.
- cancelEvent(), destroy(), detachEvents()
    - IRRELEVANT.



# Logger

IRRELEVANT



# JsObject

COMPLETE (merged into Component)

Merged into Component, because its other subclasses should actually either
extend Component or just Object.

- isInstanceOf()
    - Just use instanceof(), if you really have to.
- setElement(), getElement()
    - The DOM element is only used in __init__. See ComponentFactory above.
- getId() -> self.id
- setContext(), getContext(), setElementAndContext()
    - self.dialog (kind of)
- getPropertyAsString()
    - `self.foo_bar = element.get('foobar')`
- getPropertyAsInt()
    - `self.foo_bar = int(element.get('foobar', '0'))`
- getPropertyAsFloat()
    - `self.foo_bar = float(element.get('foobar', '0'))`
- getPropertyAsBoolean()
    - `self.foo_bar = (element.get('foobar', 'false') == 'true')`
    - `self.foo_bar = element.has_attr('foobar')` (for attrs without value)
- setProperty()
    - Use one of the type coercions above.
- getIsTemporary(), setIsTemporary()
    - Votr doesn't parse elements with `isTemporary="true"` at all.
- destroy(), cancelEvent(), isValid()
    - IRRELEVANT



# Component

COMPLETE

Most getters/setters were replaced with normal attribute access.

When a webui result frame calls a setter, Votr prefixes its name with `_ais_`.
So if a result frame calls `setEnabled("false")`, Votr calls `_ais_setEnabled`,
which does a type conversion and sets the attribute.

- getComponentType() -> self.jsct
- getState(), setState()
    - STATE_DT is UNSUPPORTED, whatever it's supposed to be.
    - Some AIS components have state 0, despite there being no difference
      between 0 and 1 (the default). Webui only ever checks if it's equal to
      STATE_DT.
- getUsedListenersMask(), setUsedListenersMask() -> self.used_listeners_mask
- getEnabled(), setEnabled() -> self.enabled
- getEnabledInUI(), setEnabledInUI() -> self.enabled_in_ui
- realizeEnability()
    - Replaced with self.is_really_enabled(), which is simpler to implement
      because it only queries the current state. (Also applies to subclasses.)
- getVisible(), setVisible() -> self.visible
- getVisibleInUI(), setVisibleInUI() -> self.visible_in_ui
- realizeVisibility()
    - Removed. Use `self.visible and self.visible_in_ui` to query visibility.
      (Also applies to subclasses.)
- getTitle(), setTitle() -> self.title
- getPopupMenu(), setPopupMenu() -> self.popup_menu
- menuItemAction()
    - IRRELEVANT. Only used in SplitPane and TabbedPaneSelector, and can be
      worked around.
- getAutosize()
    - IRRELEVANT. Only used for positioning and sizing.



# Control

PARTIAL

- setHtmlTitle()
    - IRRELEVANT
- getX(), setX(), getY(), setY(), getInlineWidth(), getWidth(), setWidth(),
  getInlineHeight(), getHeight(), setHeight(), getPastWidth(), setPastWidth(),
  getPastHeight(), setPastHeight(), isAnchor(), getAnchorLeft(), getAnchorTop(),
  getAnchorRight(), getAnchorBottom(), isParentContainerStacked(),
  getFontSize(), setFontSize(), getForeground(), setForeground(),
  getBackground(), setBackground(), setComponentStyle(), getComponentStyle(),
  realizeComponentStyle(), getFontStyle(), setFontStyle(), init(),
  resizeComponent(), realizeResizeComponent(), ie8Patch(), canFocusNext(),
  refocus(), focus(), deactivate(), isPreparedToBlur(), blur(),
  getParentsToBlur(), blurOnParentContainers(), positionContextMenu(),
  contextmenu(), click()
    - IRRELEVANT. Votr ignores positions, sizes and styles.
    - Focus and blur is UNSUPPORTED. We never send focus information to AIS,
      and blur events must be triggered manually.
    - It seems these set*() methods aren't used in result frame updates. If
      that's wrong, we just need to add empty _ais_set*() methods. (So far, we
      added setForeground and setBackground.)
    - Instead of calling positionContextMenu() or showPopupMenu(), use the menu
      items directly.
- getReadOnly(), setReadOnly() -> self.read_only
- realizeReadOnly()
    - Removed. Just use `self.read_only`. (Also applies to subclasses.)
- isDisabledDueToParents() -> not self.parent.is_really_enabled()
- isDisabled() -> not self.is_really_enabled()
- isUnvisible() -> not (self.visible and self.visible_in_ui)
- getParentContainer(), getParentContainerJSO() -> self.parent
    - Moved to Component.
- isParentContainerSplitPane()
    - IRRELEVANT - only used to call SplitPane.childChangeVisibility(), which
      is IRRELEVANT.
- getAncestorAutosizeJSO()
    - IRRELEVANT, because all functions that use it are IRRELEVANT.
- getTabOrder(), setTabOrder() -> self.tab_order
- getToolTipText(), setToolTipText() -> self.tool_tip_text
- changedProperties() -> self.changed_properties()
- updateValueInteractives() -> self.update_value_interactives()



# Container

COMPLETE (merged into Control)

- getMinWidth(), setMinWidth(), getMinHeight(), setMinHeight(),
  getOverflowed(), setOverflowed(), setElementAnchorAll()
    - IRRELEVANT
    - We should add `_ais_set...()` no-ops if webui uses the setters.
- getVisibleForUser()
    - IRRELEVANT, because all functions that use it are IRRELEVANT. See their
      respective sections.
- startChromeOverflowPatch(), endChromeOverflowPatch()
    - IRRELEVANT, because all functions that use it are IRRELEVANT.
- autosizeHeight()
    - IRRELEVANT. (Also applies to subclasses.)



# ActionableControl

COMPLETE

- getActionName() -> self.action_name
- getAction() -> self.action
- tryExecuteAction() -> self.try_execute_action()
- getEnabledByOwnerContainer() -> self.get_enabled_by_owner_container()



# Image (WebuiImage)

COMPLETE

- setImage(), setUrl() -> self.image
- setToolTipText()
    - Superclass definition suffices.



# Separator

COMPLETE



# View

UNSUPPORTED

What is it?



# EventPrototype, *Event

COMPLETE

In webui, you create an event like this: first, you call createEvent(). Then,
you check if it's not null. (That happens if the usedListenersMask indicates
that the server doesn't care about it.) Then, you call setters. Then, you ask
a confirm question, if any. Then, you fire the event.

In votr, creating the event always succeeds, and all setters were turned into
constructor arguments. If the server isn't listening, the event will have
`listening == False` and won't be sent.

Events that only have a single method no longer have the method argument.

See events.py for details.

The try_interactive() calls are inlined from DialogBody.createEvent().



# EventManager

COMPLETE

eventManager.fire() is absurdly complex and has many different code paths that
can lead to actually calling commit() to send the events. This can depend on
whether the source is an "input" tag, whether you're using the mouse or the
keyboard, what is focused, possibly whether a table cell is being edited, etc.

Votr could try to emulate all that, but we're not sure the webui code really
works. In some cases, it discards all waiting events, which doesn't seem safe.
So for now, all of the above is UNSUPPORTED.

We send every event immediately and block until it's done. There is no
{get,set}WaitingMode() or {get,set}Mouse{Up,Down}Component() or a list of
suspended events. Each request contains exactly the events you specify. Blur
events have to be sent manually when they're really needed.

- commitEvent, setWaitingMode(), getWaitingMode(), setMouseDownComponent(),
  getMouseDownComponent(), setMouseUpComponent(), getMouseUpComponent(),
  addEventToFire(), onMouseOut(), onClick(), onDblClick(),
  clearSuspendedEvents()
    - UNSUPPORTED
- createEvent()
    - See EventPrototype above.
- fire()
- commit()
    - fire() reduces to calling commit().
    - commit() reduces to calling webui.sendEvent().
    - webui.sendEvent() is implemented as app.send_events(*events)



# DialogBody

PARTIAL

Most of DialogBody is useless, and most of the rest was moved to Dialog.

Note that in webui, getDialogJSObject() returns the DialogBody, not Dialog.

- popupMenuManager
    - Removed, see PopupMenuManager below.
- actionManager
    - Removed, see ActionManager below.
- suspendedTableJSO
    - IRRELEVANT
- focusChanged, getFocusChanged()
    - UNSUPPORTED. Votr doesn't send the focused component to AIS.
- elementsChanged, getElementsChanged()
    - TODO (related to ChangeGuardInteractive)
- resized, getResized()
    - UNSUPPORTED. Votr doesn't send dialog size to AIS.
- init(), DialogBody_init()
    - Component initialization is done by Dialog._init().
    - dtSelectionDiv is UNSUPPORTED.
    - Everything else done by init() is IRRELEVANT, including the call to
      onDialogBodyInit().
- resize(), resizeComponent()
    - IRRELEVANT
- resetComponentChanges()
    - Inlined at the end of Dialog.changed_properties().
- getWidth(), getHeight(), setWidth(), setHeight()
    - IRRELEVANT
- componentCollapsingChanged()
    - IRRELEVANT -- only calls setMoveDueToOtherExpCol() which is IRRELEVANT.
- getFocusedComponentId(), setFocusedComponentId(), initFocusedElement(),
  registerFocusedComponent(), patchReactivateIE(), reactivate(),
  reactivateFocusedComponent(), getFocusedComponent(), setFocusedComponent(),
  blurFocusedComponent()
    - UNSUPPORTED. See Control above.
- addExtraComponent(), extraComponents, reactivateExtraComponents()
    - TODO. (Seems to be some extra behavior for HtmlArea.)
- setEnabled()
    - Defined in superclass, but extraComponents support is TODO.
- keydown()
    - UNSUPPORTED
    - There are some things you can only do with the keyboard (such as
      sending an ActionEvent with method="cancel"), but they're rarely needed.
- keydownTryAction()
    - UNSUPPORTED, because findActionJSOForUseKeyDown() is UNSUPPORTED
      (see below).
- keyup()
    - Only used in Safari. UNSUPPORTED.
- click(), dblclick(), contextmenu(), mousemove(), mousedown(), mouseup(),
  dtResetSelection(), testComp(), showPopupMenus(), mouseover(),
  keydownPopupMenus(), mouseupPopupMenus(), isMenuActivated()
    - IRRELEVANT
    - STATE_DT and dtSelection is UNSUPPORTED.
    - Votr doesn't keep track of open popup menus. See PopupMenu below.
    - Multiple dialog stacks are UNSUPPORTED, so setActiveDialog() is a no-op.
- close()
    - Inlined into Dialog.click_close_button().
- isStyleUnknown(), unknowStyles
    - Why would you ever do such a thing?! IRRELEVANT.
- tryInteractive()
    - Moved to Dialog.try_interactive().
- componentChanges()
    - Moved to Dialog.component_changes().
    - The fourth argument (property value) was never used.
    - The third argument (property name) was only used in
      webui.onComponentChanges() in a way that's probably IRRELEVANT to us.
    - So we only kept the first two arguments.
- createEvent()
    - Removed, see EventPrototype above.
    - The tryInteractive() call was inlined in the event creating functions.
- onBeforeFireEvent()
    - Blur is UNSUPPORTED.
- getXMPIsland()
    - Finds the element with the given id in the result frame.
    - Replace with `body.find(id=id)` and mark the setter with `wants_body`.
- unReadOnlyElement(), DialogBody_unReadOnly()
    - IRRELEVANT
- tabOrdering, getTabOrdering()
    - UNSUPPORTED
- focusNextElement(), focusPreviousElement()
    - UNSUPPORTED
- initializedComps, addToInitializedComps(), destroy()
    - IRRELEVANT
- retrieveAllComponentIds(), retrieveIdAndComponentType()
    - IRRELEVANT (seems to be unused in webui)
- initCalendarSelector(), getCalendarSelector(), calendarBackButtonClick(),
  calendarForwardButtonClick(), calendarMiniTableClick(), calendarMouseDown()
    - UNSUPPORTED (likely IRRELEVANT)
- dtSelect(), getElementPath(), dtDeselect(), isElementSelected(),
  addRemoveDtSelection(), setDtSelection(), clearDtSelection(),
  manageDtSelection(), manageAreaSelection(), manageAreaSelectionTimer(),
  selectElementsBetweenComponents(), dtSelectElementsBelongingToArea(),
  getAbsolutePosition(), JSObjectBelongsToArea(), isDtSelectionOn(),
  getDtSelectionAsString(), relocateDtSelection(), doRelocateDtSelection()
    - STATE_DT and dtSelection is UNSUPPORTED.



# Dialog

PARTIAL

- setThis()
    - Inlined into Dialog.__init__().
- getName() -> self.name
- getParentDialogName() -> self.parent_dialog_name
- getModal() -> self.modal
- getMainDialog() -> self.is_main_dialog
- getResizeable()
    - IRRELEVANT (only affecting positioning and visuals)
- getMinimizeable()
    - IRRELEVANT (unused in webui)
- getDialogBase(), getDialogIframe(), dialogContext, getDialogContext(),
  getDialogBody()
    - IRRELEVANT (DOM objects)
- getDialogBodyJSObject() -> self.body
- dialogIframeLoaded, dialogContentIframeLoaded, childrenDialogIsWaiting
    - IRRELEVANT (Votr is synchronous, opening a dialog is blocking)
- getMyDialogStack()
    - See below for DialogStack.
- isNative
    - UNSUPPORTED, see openDialog().
- active, getActive() -> `self == self.app.active_dialog`
- enabled
    - Removed.
    - Means whether the dialog reacts to mouse clicks. This is false if another
      modal dialog is open. See DialogStack.
    - Votr checks this in Application.activate_dialog(), so a dialog that isn't
      "enabled" can't become active. But otherwise, Votr doesn't prevent the
      user from accessing "disabled" dialogs. So it's best if the user only
      uses the active dialog and switches between them with activate_dialog().
- moved
    - UNSUPPORTED
- dialogArguments
    - IRRELEVANT (only used in nativeDialogBody.js)
- capturingElement, useTitleRow(), useResizers(), useDialogTitleFrame(),
  getTitleRowHeight(), getFrameWidth(), getDoubleFrameWidth(),
  setMinBodyWidth(), setMinBodyHeight(),
  createDialogIframeBody(), addResizer(), onLoad(), moveResizers(),
  computeInitPosAndSize(), getAbsPosAndSizeOfControl(), setTitle()
    - IRRELEVANT
- retrieveAllComponentIds(), retrieveIdAndComponentType()
    - IRRELEVANT (seems to be unused in webui)
- init() -> Dialog.__init__(), Dialog._init()
    - Largely IRRELEVANT.
- refresh() -> Dialog._init()
- activate()
    - IRRELEVANT. Only handles focus and whether the dialog visually appears
      active (focused window).
- setEnabled()
    - Shows or hides the "disable glass" to control whether the dialog responds
      to mouse clicks.
    - IRRELEVANT. See enabled above.
    - For simplicity, Votr skips enabling/disabling the dialog body.
- hideByJaws(), isHiddenByJaws(), showByJaws(), prepareUpdating(),
  showDisableGlass(), hideDisableGlass(), onDialogBodyInit(),
  onNativeDialogBodyInit()
    - IRRELEVANT
- closeButtonClick() -> self.click_close_button()
- getInRequestEnabledComponents()
    - IRRELEVANT. Votr is synchronous, nothing can happen during a request.
- makeClip(), showGlassForMove(), titleRowMouseDown(), onMouseDown(),
  resizerMouseDown(), moveDialogGlassMouseMove(), moveDialogGlassMouseUp(),
  fillBaseAndBodySize(), resize(), resizeDialogBase(),
  resizeDialogContentIframe(), setWidthFromBody(), setHeightFromBody(),
  resizeByBody(), workspaceResize()
    - IRRELEVANT
- changedProperties() -> ""
    - IRRELEVANT (dialog position and focus is unsupported)
- close()
    - IRRELEVANT. Only destroys the DOM.



# DialogStack

COMPLETE (merged into Application)

DialogStack keeps track of the list of dialogs. It also knows which is the
"desired active dialog" and which is the "top modal dialog". (The real variable
names were optimized away.) This is put to effect in reinit() and activate(). If
any modal dialog exists, the "desired active dialog" doesn't matter and the top
modal dialog wins -- only it is active (the window appears focused) and enabled
(the content is clickable). Otherwise, all dialogs are enabled and the "active
dialog" appears focused. However, in practice all dialogs except the main dialog
are modal in AIS.

Note that dialog.closeProgress is always false in Votr, as closing a dialog is
a blocking operation. The code using dialogs is responsible for not using them
after they are closed.

- activate()
    - Implements the rules outlined above. Both Dialog.activate() and
      Dialog.setEnabled() are IRRELEVANT (except for the call to
      DialogBody.setEnabled(), which we skip for simplicity) and so this
      function is also IRRELEVANT.
- reinit()
    - Implements the rules outlined above. Inlined in Application.open_dialog()
      and Application.close_dialog().
- pushDialog()
    - Inlined in Application.open_dialog().
- removeDialog()
    - Inlined in Application.close_dialog() and Application.close_all_dialogs().
- getDialog() -> `app.dialogs[name]`
- getTopDialog() -> `app.dialog_stack[-1]`
- getBaseDialog() -> `app.dialog_stack[0]`
- getActiveDialog() -> `app.active_dialog`
- setActiveDialog() -> `app.activate_dialog(name)`
- isEmpty() -> `not app.dialog_stack`
- isTop() -> `d == app.dialog_stack[-1]`
- workspaceResize()
    - IRRELEVANT
- size() -> `len(dialog_stack)`
- loadedAllDialogs() -> `True`
- getLevel() -> `dialog_stack.index(d)`
- prepareUpdatingDialogs()
    - IRRELEVANT



# DialogManager

PARTIAL (merged into Application)

Opening and closing dialogs is blocking in Votr, so there's no need to handle
dialogs that aren't fully loaded, queue waiting dialogs, etc.

- getDialogTitleRowHeight(), getDialogFrameWidth(), areDialogsPrepared(),
  onSomeDialogBodyInitialized(), resizeBrowser(), resizeIframeHeight(),
  openWaitingDialogs(), closeWaitingDialog(), workspaceResize(), hideByJaws(),
  prepareUpdatingDialogs()
    - IRRELEVANT
- resizeNoAccessibleIframe()
    - UNSUPPORTED
- openMainDialog()
    - Application.open_main_dialog()
    - useDialogFrame is IRRELEVANT (it only affects positioning and visuals).
- openDialog()
    - Application.open_dialog()
    - isNative is UNSUPPORTED. (TODO: it seems this *is* NativeDialog after
      all. dm.messageBox() calls showNativeDialog() which calls openDialog()
      with isNative true. Figure this out.)
    - Multiple dialog stacks are UNSUPPORTED.
    - x, y, width, height, resizeable, minWidth, minHeight, forControlOfParent
      are IRRELEVANT (only affecting positioning and visuals). minimizeable is
      unused in webui.
- openDialog_()
    - Merged with openDialog(), as useDialogFrame is IRRELEVANT.
- getDialog() -> `app.dialogs[name]`
- getActiveDialog() -> `app.dialog_stack[-1]`
- getMainDialog()
    - Unused in webui.js, but perhaps used elsewhere.
    - Removed. Store the result of open_main_dialog() in a variable.
- closeDialog(), checkDialogStacksEmpty()
    - Application.close_dialog()
    - Note that `isNative` is an optional argument.
    - Calling `webui.clean(true)` when no dialogs remain is TODO.
- closeAllDialogs()
    - Application.close_all_dialogs()
- canKillApplication()
    - IRRELEVANT. Only used in beforeUnload().
- disableAllDialogs() -> no-op
- setActiveDialogName() -> no-op (we have a single dialog stack)
- setActiveDialog() -> no-op
    - Focus management and multiple DialogStacks are UNSUPPORTED.
    - dialog.setActiveTitle is IRRELEVANT.
- reactivateDialogs()
    - IRRELEVANT -- only used in enableApplication(), which is not used in Votr
      (the API is synchronous and not reentrant)
- refreshDialog() -> Application.refresh_dialog()
- loadedAllDialogs() -> `True`
- retrieveAllComponentsIdsFromActiveDialog(),
  retrieveIdAndComponentTypeOnActiveDialog()
    - IRRELEVANT (seems to be unused in webui)
- fillImageUrl() -> `'/ais/images/' + value + '.png'`
- messageBox(), confirmBox(), fileUpload(), fileXUpload(), editDoc(),
  abortBox(), onLoadAbortBox(), showNativeDialog(), showNextNativeDialog(),
  onNativeDialogClosed(), onMessageBoxClose(), onConfirmBoxClose(),
  closeAbortBox(), onFileUploadSubmit(), onFileUploadCancel(),
  closeFileUpload(), onFileXUploadClose(), onEditDocClose()
    - TODO



# FocusManager

UNSUPPORTED

Votr tries to ignore focus as much as possible. The webui focus system is
a mix of webui code and builtin browser behavior. Reimplementing it faithfully
would be a lot of work for little gain.



# StyleManager

IRRELEVANT



# NativeDialog

TODO



# MessageBox, ConfirmBox, FileUpload, FileXUpload, EditDoc, AbortBox

TODO



# ActionList

COMPLETE

- getOwnerContainerName() -> self.owner_container_name
- getOwnerContainer() -> self.owner_container
- getVisibleForUser()
    - IRRELEVANT, because all functions that use it are IRRELEVANT. See their
      respective sections.



# Action

COMPLETE

Like in webui, the `_ais_set*()` setters will also modify the associated
buttons and menu items.

- getComponents() -> self.get_components()
- getButtonMenuItemJSObjects() -> self.get_button_menu_item_js_objects()
- getAccessible(), setAccessible() -> self.accessible
- getToolTipText(), setToolTipText() -> self.tool_tip_text
- getConfirmQuestion(), setConfirmQuestion() -> self.confirm_question
- init() -> `__init__`
- onExecute() -> self.execute()
    - The first argument was removed. Setting it to True is UNSUPPORTED,
      because DialogBody.keydownTryAction() is UNSUPPORTED.
    - The fourth argument was removed, because addEventToFire is UNSUPPORTED.
- getFirstFocusableComponent()
    - Removed. Only used in `onExecute(true, ...)` which is UNSUPPORTED.



# ActionManager

COMPLETE (removed)

- getEventShortCut()
    - Removed. Only used in findActionJSOForUseKeyDown().
- findActionJSOForUseKeyDown()
    - UNSUPPORTED, because no known actions have a shortCut attribute.
- initActionForElement()
    - IRRELEVANT, because ensureJSO() is IRRELEVANT.
- getActionListForAction() -> `action.parent`
- updateEnabilityForActionListByOwnerContainer()
    - IRRELEVANT, because realizeEnability() was removed.
- tryExecuteActionForElement()
    - Use `self.try_execute_action()` if possible, and inline it if not.



# Button

COMPLETE

- setPopupMenu()
    - Webui version doesn't work, because it doesn't call the super method.
      (And they actually define the method twice.) Votr just uses superclass.
- getAccessKey(), setAccessKey() -> self.access_key
    - Webui doesn't use it directly, it's a standard HTML attribute.
- getImage(), setImage() -> self.image
- setTitle(), updateTitleImageElements()
    - IRRELEVANT
- getConfirmQuestion(), setConfirmQuestion() -> self.confirm_question
- click()
    - self.click()
    - showPopupMenus() is IRRELEVANT. See PopupMenu below.
- mousedown()
    - IRRELEVANT



# CheckBox

COMPLETE

- init() -> `__init__`
- getTitle(), setTitle() is inherited
    - The overridden getTitle() is not needed in practice, the _title attribute
      (used by Component) contains the same text.
- getSmoked(), setSmoked() -> self.smoked
- getSelected(), setSelected() -> self.selected
- realizeEnability(), realizeReadOnly(), realizeEnabilityAndReadOnly(),
  refocus()
    - IRRELEVANT
- fireUIChangesEvent() -> self._fire_event()
- changedProperties() -> self.changed_properties()
- propertychange(), change(), mousedown(), mouseup(), mouseout(), click(),
  keydown()
    - Replaced with self.toggle() and self.set_to().



# Label

COMPLETE

Added `self.text` which is the actual text content.

- replaceBrackets()
    - Removed. `self.title` should be handled as plaintext, and escaped when
      shown in a HTML document.
- setTitle() is inherited
- getTitleLikeText(), setTitleLikeText() -> self.title_like_text
- getFor(), setFor() -> self.for_



# Panel

COMPLETE

- getChildrenElements(), getOverflowElement(), getHasTmpPanel(),
  tryParentStackedPaneAutosize(), autosizeHeight(), computeResizeDiff(),
  resizeChildren()
    - IRRELEVANT, because all functions that use it are IRRELEVANT.
- getTabId() -> self.tab_id
- getMyTabbedPaneJSO(), isOnTabbedPane(), setComponentStyle()
    - IRRELEVANT
- getTitle(), setTitle() -> self.title (`_ais_setTitle()` is inherited)
- blur()
    - The call to componentChanges() might be TODO. (Ditto in StackedPane.)
- getAutoscrolls() -> self.autoscrolls
- getCollapsed(), setCollapsed() -> self.collapsed
    - In webui, setCollapsed() calls realizeCollapsed() which can send an
      event. This was removed in votr so that it won't loop infinitely.
      (Webui shouldn't loop, because events that happen while processing
      the last event are probably discarded.)
    - Instead, toggle_collapsed() calls _fire_event().
- getCollapsable() -> self.collapsable
- getCollapsedHeight(), setExpandedHeight(), getExpandedHeight(),
  getExpandCollapseButton()
    - IRRELEVANT
- click() -> self.toggle_collapsed()
- getFirstFocusableComponent()
    - IRRELEVANT
- realizeCollapsed()
    - Reduces to this.fireUIChangesEvent().
- fireUIChangesEvent() -> self._fire_event()
- changedProperties() -> self.changed_properties()
- setMoveDueToOtherExpCol()
    - IRRELEVANT
- IRRELEVANT methods of superclasses are still IRRELEVANT.



# SplitPane

COMPLETE

orientation and lastDividerLocation are UNSUPPORTED. This makes everything else
IRRELEVANT, including fireUIChangesEvent() and changedProperties().



# StackedPane

COMPLETE

- getChildrenElements(), getOverflowElement(), resizeChildren()
    - IRRELEVANT, because all functions that use it are IRRELEVANT.
- getTitle(), setTitle() -> self.title (`_ais_setTitle()` is inherited)
- tryAutosize(), getFirstFocusableComponent()
    - IRRELEVANT
- IRRELEVANT methods of superclasses are still IRRELEVANT.



# ProgressBar

COMPLETE

- getMaximum(), setMaximum() -> self.maximum
- getValue(), setValue() -> self.value



# TabbedPaneSelector

IRRELEVANT

Everything interesting is stored in TabbedPane. TabbedPaneSelector is just
an UI. The `title`, `enabled` and `visible` of a tab is always the same as
in the corresponding panel, so we don't store them in TabbedPane at all.

setEnabledForPanelTab(), setVisibleForPanelTab(), setTitleForPanelTab() and
setComponentStyleForPanelTab() are thus IRRELEVANT.



# TabbedPane

COMPLETE

- getSelector(), setSelector()
    - IRRELEVANT, see TabbedPaneSelector above.
- getSelectedIndex(), setSelectedIndex() -> self.selected_index
- setSelectedIndexWithFire() -> self.select()
- getSelectedPanel(), getSelectedPanelJSO() -> self.get_selected_panel()
- panels -> self.get_panels()
    - This is to avoid issues with component initialization order.
- arena -> local variable in `__init__`
- resizeContent(), showSelectedPanel()
    - IRRELEVANT
- changedProperties() -> self.changed_properties()
- fireUIChangesEvent() -> self._fire_event()
- setEnabledForPanelTab(), setVisibleForPanelTab(), setTitleForPanelTab(),
  setComponentStyleForPanelTab()
    - IRRELEVANT, see TabbedPaneSelector above.



# UpDown

COMPLETE

- getUpDownedComponent() -> self.up_downed_component
- getTopBottomEnabled() -> self.top_bottom_enabled
- udc -> local variable in `click`
- click() -> self.click(), self.click_up(), self.click_down(),
  self.click_top(), self.click_bottom()
- upDown()
    - Inlined in click()



# ComboBox

COMPLETE

- tf
    - Webui replaces the `<select>` with a TextField when it's read only.
    - IRRELEVANT
- refreshBackgroundColor()
    - IRRELEVANT
- getReadOnly(), setReadOnly() is inherited
- getToolTipLikeData() -> self.tool_tip_like_data
- select() -> self.select()
- selectId(), selectTitle()
    - Removed. Find the right index in self.options, then use select(index).
- getSelectedTitle() -> self.selected_option.title
- getSelectedIndex() -> self.selected_index
- getSelectedId() -> self.selected_option.id
- getSelectedToolTipText() -> self.selected_option.tool_tip_text
- focus(), mousedown(), keydown(), keypress()
    - IRRELEVANT
- change() -> self.select() (kind of)
- fireUIChangesEvent() -> self._fire_event()
- changedProperties() -> self.changed_properties()
- setDataView(), setDataViewEx() -> self._ais_setDataView()
- ComboBox_updateOptions() -> self._parse_options()



# List

TODO



# UpDownList

TODO



# ListBox

TODO



# RadioBox

COMPLETE

- setTitle()
    - The code doesn't make sense, so we just use the inherited method.
- init() -> `__init__`
- allwaysSelected -> self.always_selected (fixed webui typo)
- mousedown(), mouseup(), mouseout(), refocus(), focusOrSetActiveRadio(),
  focus(), realizeEnability(), realizeReadOnly(), realizeEnabilityAndReadOnly()
    - IRRELEVANT
- click(), changeSelection(), select(), selectId() -> self.select() (kind of)
    - The calculations in select() just convert index to td element (the table
      can have multiple rows and columns). We don't need that.
- selectedItem -> self.selected_option
- getSelectedIndex() -> self.selected_index
- getSelectedId() -> self.selected_option.id
- getSelectedTitle() -> self.selected_option.title
- findItem() -> `element.find_parent("td")`
- findRadioInput() -> `element.radio`
- findRadioLabel()
    - IRRELEVANT
- fireUIChangesEvent() -> self._fire_event()
- setDataView() -> self._ais_setDataView()
- changedProperties() -> self.changed_properties()



# CheckList

COMPLETE

TODO: CheckList is currently based on an older version of webui.js where it
wasn't a subclass of UpDownList.

- mode, MSELECT, MMOVE
    - Removed. `this.mode` should've been just an argument to up() and down().
- getUpDownEnabled(), setUpDownEnabled() -> self.up_down_enabled
- upDownRow(), up(), down(), swapNode()
    - TODO (make CheckList a subclass of UpDownList)
- initSelectedRow()
    - IRRELEVANT
- selectUnselectAll() -> self.select_unselect_all()
- getSelectedIndex() -> self.selected_index
- refocus(), focus(), blur(), mousedown(), keydown(), scrollToVisible()
    - IRRELEVANT
- click() -> self.select(index), self.toggle(index)
- markRowSelection(), select() -> self.select(index)
    - This doesn't call fireUIChangesEvent(), which is weird and might be
      a bug, but we preserve it.
- getSelectionAsString(), resetSelection()
    - Inlined in self.changed_properties()
- findItem() -> `element.find_parent("tr")`
- recolorTable() -> no-op
- setDataView() -> self._ais_setDataView()
- fireUIChangesEvent() -> self._mark_changed()
- changedProperties() -> self.changed_properties()



# HtmlList

TODO



# RadioButton, RadioGroup

UNSUPPORTED

We need a markup example, and all known dialogs just use RadioBoxes.

Note that getAccessibleRadioButtons() is IRRELEVANT, because it only concerns
focus. (This is written here to show that getVisibleForUser() is IRRELEVANT.)



# TextControl

COMPLETE

- getText()
    - IRRELEVANT (only used in )
- getReadOnly(), setReadOnly() is inherited
- getMaxLength(), setMaxLength() -> self.max_length
- getToolTipLikeText(), setToolTipLikeText() -> self.tool_tip_like_text
- getEnterToNext(), setEnterToNext() -> self.enter_to_next
- getPlaceHolder(), setPlaceHolder() -> self.placeholder
- getIsEditable() -> self.is_editable()
- getDefaultBackground(), setDefaultBackground(), getReadOnlyBackground(),
  setReadOnlyBackground(), initPlaceHolder(), hidePlaceHolder(),
  showPlaceHolder(), adjustPlaceHolderVisibility(), realizeComponentStyle(),
  realizeEnability(), refreshBackgroundColor()
    - IRRELEVANT
- contextmenu(), regActualSelectionIE(), regActualSelection(), setPosition(),
  removeReplaceSelectedText(), removeReplaceCharacter()
    - Deals with selection. Very likely IRRELEVANT.



# TextInput

COMPLETE

- changingKeyUpEvent(), changingKeyPressEvent()
    - IRRELEVANT
- changeHandler, setChangeHandler()
    - IRRELEVANT, because:
    - Used for editable fields in tables. The changeHandler is a TableModel.
    - Two methods are called on it: tryToAutoFocusNext(), valueChange().
    - tryToAutoFocusNext() is IRRELEVANT.
    - valueChange() does not exist in webui.js.
- propertychange(), fixMaskOnDelete(), paste(), afterPaste(), cut(), afterCut()
    - Removed. Their goal seems to be to preserve the mask after various
      text editing operations. In Votr, the user is responsible for that.



# TextArea

COMPLETE

- getText(), setText() -> self.value
- getResizeHeightByContent(), focus(), blur(), keydown(), keypress(), keyup(),
  drop(), dragstart(), tryAutosize()
    - IRRELEVANT
- countNewLines(), regActualSelectionIE(), setPosition(), paste(),
  afterPaste(), cut()
    - IRRELEVANT to Votr. But the strange thing is, it should be irrelevant to
      webui as well. Why is all this code in there?
    - It handles getMaxLength() and fireUIChangesEvent(), but you could do that
      without dealing with selections, cut and paste, etc. I just don't get it.
- change(), fireUIChangesEvent()
    - Inlined in self.write()
- changedProperties() -> self.changed_properties()



# DateControl

COMPLETE

- validDate -> self.value
- getText(), setText() -> self.value
- setRawText()
    - IRRELEVANT, only called from TableModel
- XcrementDate()
    - UNSUPPORTED, use Python date libraries instead if needed
- initDateParts(), setDay, setMonth, setYear, adjustDay, incrementDay(),
  decrementDay(), incrementMonth(), decrementMonth(), incrementYear(),
  decrementYear(), zeroPad()
    - UNSUPPORTED, only called from XcrementDate()
- getDate()
    - Converts value to a Date object.
    - Only called in CalendarSelector.setDateControl.
    - UNSUPPORTED
- getMinValue() -> self.min_value
- getMaxValue() -> self.max_value
- getSubstituteChar(), setSubstituteChar() -> self.substitute_char
- getSubstituteMask(), setSubstituteMask() -> self.substitute_mask
- getMask(), setMask() -> self.mask
- getCalendarEnabled(), setCalendarEnabled() -> self.calendar_enabled
- getInvalidDateMessage(), setInvalidDateMessage()
    - IRRELEVANT
- fireUIChangesEvent()
    - Inlined in self.write()
- changedProperties() -> self.changed_properties()
- dayStart, monthStart, yearStart, yearLength, hoursStart, minutesStart,
  secondsStart
    - UNSUPPORTED because all users are UNSUPPORTED
- init() -> `__init__`
- adjustCalendarButtonVisibility()
    - IRRELEVANT
- setCalendarVisible(), setDateFromCalendar()
    - UNSUPPORTED
- isPreparedToBlur(), alertAndFocusBadInput(), blur(), focus(), mousewheel(),
  keydown(), keypress(), canFocusNext(), afterPaste(), afterCut(), drop(),
  dragstart(), change(), getDatePosition()
    - IRRELEVANT
- showDate()
    - Unused?
- getShowDate()
    - Converts a Date object to a string according to mask. UNSUPPORTED.
- checkDateOnBlur(), checkDate()
    - UNSUPPORTED
- fillPartSubstituteChars()
    - probably IRRELEVANT
- fillSubstituteCharsInDateFormat()
    - Converts value to a form understood by Date.parse(). UNSUPPORTED.
- calendarButtonKeyDown(), click(), calendarButtonClick()
    - IRRELEVANT


# CalendarSelector

UNSUPPORTED



# HtmlArea

COMPLETE

- setHtml() -> self._ais_setHtml()
- getBorderWidth(), initIframeWindow(), resizeComponent(), realizeEnability()
    - IRRELEVANT
- initFromDataView() -> self._parse_content()
- tryExecuteAction()
    - Equivalent to ActionableControl's version.
- fireUIChangesEvent()
    - IRRELEVANT, because canClose is UNSUPPORTED
- changedProperties() -> self.changed_properties()
- bodyContextMenu(), bodyMouseDown()
    - IRRELEVANT
- getCanClose()
    - UNSUPPORTED, because we don't actually parse or execute the content.
- tryExecuteActionFromHtmlArea() -> self.try_execute_action()
- tryShowPopupMenuFromHtmlArea()
    - Mostly IRRELEVANT, see PopupMenu below.
    - If this function receives non-null params, WebUI stores the value in
      PopupMenuManager and uses it in MenuItem.onAction(). This can be done in
      Votr by calling MenuItem.click() with the needed params.



# NumberControl

PARTIAL

NumberControl operates on BigDecimal values with arbitrary precision, usually
stored as strings. But webui shows this value in two different formats, and
unfortunately, it uses one `<input>` for both, depending on if it's focused or
not. See setShowValue() and setEditValue().

- getBDValue(), setBDValue()
    - Gets and sets the raw BigDecimal value (as a string).
- getValue(), setValue()
    - getValue() is the same as getBDValue()
    - setValue() can convert *some* locale values to raw BigDecimal values. It
      removes leading zeroes, replaces `decimalPoint` with a dot, and adds up
      to `scale` zeroes in the fractional part. But it doesn't handle the
      thousands separator, or check whether a fractional part is even allowed.
      Then it also calls componentChanges() and updates the visible text field.
    - The above is also true for other users of fillBdvalue().
- getText(), setText()
    - getText() returns the locale formatted number.
    - setText() converts the locale formatted number to bdvalue. Probably.

And that's just the beginning. Untangling this mess seems like a waste of time
for Votr, so our NumberControl only implements the easy parts and the bare
minimum needed to send requests and receive responses.

- getSeparator1000(), setSeparator1000() -> self.separator_1000
- getDecimalPoint(), setDecimalPoint() -> self.decimal_point
- getScale(), setScale() -> self.scale
- getNegativeEnabled(), setNegativeEnabled() -> self.negative_enabled
- getMinValue(), setMinValue() -> self.min_value
- getMaxValue(), setMaxValue() -> self.max_value
- getShowMaxLength(), setShowMaxLength() -> self.show_max_length
- getEditMaxLength(), setEditMaxLength() -> self.edit_max_length
- setLengths() -> self.show_max_length, self.edit_max_length
- getBDValue(), setBDValue() -> self.bdvalue
- getValue(), setValue(), getText(), setText()
    - UNSUPPORTED for now, see above
- switchMode(), stopEdit(), removeSeparators1000(), fillDecimalByNulls(),
  toBdValue(), fillBdvalue(), getBDValueAsText(), setShowValue(),
  setEditValue(),  focus(), isPreparedToBlur(), getValueNotInRangeMessage(),
  blur(), checkValueOnBlur(), checkValue(), keydown(), isCodeSignum(),
  isCharSignum(), keypress(), drop(), dragstart(), afterPaste(), paste(),
  parseTextToBigDecimal(), cut(), change()
    - UNSUPPORTED for now
- fireUIChangesEvent()
    - Inlined in self.write()
- changedProperties() -> self.changed_properties()

If NumberControl is supposed to call updateValueInteractives() or
tryInteractive(), that's also TODO.



# TextField

PARTIAL

Like with NumberControl, it's just not worth it to reimplement more than the
bare minimum. In particular, masks and suggestion requests are not supported.

- getLabelDisplay(), setLabelDisplay() -> self.label_display
- getText(), setText() -> self.value
- setRawText()
    - IRRELEVANT, only called from TableModel
- getType(), setType() -> self.type
- getSelStart(), setSelStart()
    - IRRELEVANT, only used in focus()
- getSuggestionsEnabled(), setSuggestionsEnabled() -> self.suggestions_enabled
- getSuggestionsMultiValueEnabled(), setSuggestionsMultiValueEnabled() ->
  self.suggestions_multi_value_enabled
- fireUIChangesEvent() -> self._mark_changed()
- changedProperties() -> self.changed_properties()
- getInvalidMaskInputMsg(), setInvalidMaskInputMsg(), getMask(), setMask(),
  init(), focus(), blur(), canFocusNext(), isPreparedToBlur(),
  getNextEditablePartPos(), getPreviousEditablePartPos(), keydown(),
  keypress(), keyup(), getPatternForSuggestionRequest(),
  setTextFromSuggestion(), setSuggestions(), suggestionClick(), drop(),
  dragstart(), change(), getSubstituteMask(), isIdentifierChar(),
  removeNotIdentifierChars(), afterPaste(), afterCut(), checkMask(),
  checkMaskValue(), fireSuggestionConfirm()
    - UNSUPPORTED for now



# MaskChar, Mask, Suggestions

UNSUPPORTED

They probably aren't that hard to port, but TextField's usage of them is.



# TableService

See Table for an overview. TableService mostly deals with the DOM and what's
visible, so it's largely IRRELEVANT. The rest was moved directly to Table.

- init(), destroy(), getTM(), getSM(), cacheElements(), getRowByRowElement(),
  getHeaderRow(), getRow(), getFixedRow(), getCellByEvent()
    - IRRELEVANT
- doHeaderRowInDataTabExist()
    - UNSUPPORTED for now. It seems the first row of dataTab might be a header
      that doesn't count as a data row, but we've never seen it happen.
- getDataRowsCount() -> len(self.loaded_rows)
- getTableModelRowIdByIndex() -> self.loaded_rows[i].rid
- getIndexByTableModelRowId()
    - UNSUPPORTED for now. This iterates over all rows searching for the given
      rid. Do it manually if needed.
- getDataRowByIndex() -> self.loaded_rows[i]
- getDataRowByIdFromTable(), getDataRowById(), getFixedDataRowById() -> TODO
- setDataTabTopPosition(), resizeAreaHeight(), resizeDataArea(),
  showRowControlRowCountButton(), showControlButtons(),
  updateStatusControlSortButton(), setRowNumberLabel(), updateRowNumberLabel(),
  setRowIndexLabel(), updateStatusSelection(), updateDataAndCursorWidth(),
  setScrollAreaTop(), resize(), resizeContainerWidth(), manageScrollBars()
    - IRRELEVANT
    - TODO: look at showControlButtons() and ensure their visibility is in the API.
- setCursorRow()
    - Inlined into select(), along with onDataTabActiveIndexChange().
- scrollTopContentTo(), adjustScroll()
    - IRRELEVANT
- onTableContainerScroll()
    - Inlined in scroll_down(), along with onScrollVerticaly() and
      loadDataOnScrollDown(). Commonly used from all_rows().
- onVerticalScrollBarScroll(), onHorizontalScrollBarScroll(),
  scrollCellToVisible(), showHideNoDataLoadedMessage(),
  showLoadingDataMessage(), showNoDataLoadedMessage(), showMessageArea(),
  onBodyDeactivate(), focusFrameContent(), doesTableLookAsFocused(),
  ensureTableLooksAndIsKnownAsFocused(), ensureTableLooksAsBlured()
    - IRRELEVANT
- getInvertedSelection(), setInvertedSelection() -> self.inverted_selection
- manageTab(), isControlButtonDisabledOrHidden(), realizeDisable(),
  onToolsButtonClick(), onToolsButtonContextMenu()
    - IRRELEVANT
- menuItemAction(), updateInternalPopupMenu()
    - TODO
- onHeaderSpanMouseDown(), onHeaderSpanMouseUp(), onHeaderSpanClick(),
  onHeaderSpanContextMenu()
    - IRRELEVANT
- startResize(), moveSeparator(), resizeColumn(), startMove(), moveColumn(),
  insertColumn(), sort()
    - TODO (expose in API nicely)



# TableSelectionModel

See Table for an overview. The actual storage of what's selected has been moved
to Table. The row and cell coloring code is IRRELEVANT.

- init(), getTM(), getTS(), destroy(), getComputeColorForSelection(),
  getSelectionCellsIncluding()
    - IRRELEVANT
- rowSelectionContains() -> `row.id in self.selected_row_indexes`
- getSelectedRowsCount() -> `len(self.selected_row_indexes)`
- getSelectedRowsAsString() ->
  `','.join(str(r) for r in self.selected_row_indexes)`
- getSelectedRowsIdAsString() ->
  `','.join(str(self.loaded_rows[r].rid) for r in self.selected_row_indexes)`
- getCellSelection()
    - IRRELEVANT (unused in webui)
- getCellSelectionAlias() -> self.selected_column_alias
- selectRow(), selectCell(), selectCellByAlias(), unselectRow(),
  clearRowSelection(), clearCellSelection()
    - Only used in TableModel, inlined there.
- getStartBlockRowElement()
    - IRRELEVANT (used to remember where we started Shift-selecting rows)
- highlightRow(), highlightCell(), recolorRow(), recolorRowCells(),
  recolorCell(), recolorRowSelection(), recolorSelection(), changeImage(),
  initSelColors(), initCellSelColorsInRow(), initCellSelColors(),
  ensureContainerFocusBlurColors(), getFgSelectionColor(), getBgSelectionColor()
    - IRRELEVANT



# CellEditor, CellEditorManager

WebUI supports editable cells and goes to great lengths to emulate features seen
in native spreadsheet applications. (Well, except it still works as well as the
rest...) This makes the code quite complicated in multiple ways.

First, there are many editor types: checkBox, textField, dateControl, comboBox,
buttonNumCode, numberControl and readOnly. We still haven't seen most of them.

Many of these editor types use WebUI components under the hood (TextField,
NumberControl etc), but these components are specially created for the cell
editor and not a normal part of dialogs.

Second, for most editor types, editing is not an instant operation. You start
editing, and some time later, you stop, at which point WebUI needs to process
the new value and send an event. And you can only edit one cell at a time. This
means a lot of WebUI code, even otherwise unrelated to tables, needs to check if
you're currently editing a cell to make sure nothing is lost.

Votr doesn't need to deal with any of that. It would complicate both the API and
the implementation. In Votr, an edit is always an instantaneous operation, and
the various editor types are mostly ignored when possible.



# Column

- getColElement()
    - IRRELEVANT
- getAlias() -> self.alias
- getIndexInTableElement() -> self.index
- getSortable() -> self.sortable
- getFixed() -> self.fixed
- setCellEditor(), getCellEditor()
    - IRRELEVANT
- getVisible() -> self.visible
- init()
    - Inlined in aaaaaa.



# ColumnModel

- init()
    - Inlined in Table._init_from_data_view().
- getColumn() -> self.columns[i]
- getColumnByAlias() -> self.column_map[alias]
    - No longer case insensitive.
- getColumnByDataCell()
    - IRRELEVANT
- toXML()
    - Inlined in changed_properties().
- destroy()
    - IRRELEVANT



# TableHandler

IRRELEVANT. Event handlers defined in tableFrameHandler.js call functions in
TableHandler, which in turn calls real methods in other classes.



# TableModel

See Table for an overview. TableModel has been merged into Table.

- getDataRowHeight(), getSM(), getTS(), getCM()
    - IRRELEVANT
- init()
    - Inlined into self._init_from_data_view().
- update(), updateSelection()
    - IRRELEVANT. These functions are responsible for updating the DOM and
      TableSelectionModel etc. after selection data is updated from the server
      in Table. But as described in the Table overview, Votr doesn't store
      selection twice.
    - Inlined into _update_selection_model_properties().
    - All validation of selected indexes and the cursor has been removed. If
      the server refers to indexes that aren't loaded, Votr won't change the
      selection and cursor position.
- getLastTotalRowCount(), getLastScrollTop()
    - IRRELEVANT
- getCursorRowIndex() -> self.cursor_row_index
- reset()
    - IRRELEVANT (unused)
    - Equivalent to clearSelection(), see below.
- onTableContainerSelectStart(), onTableContainerClick()
    - IRRELEVANT
- onTableContainerKeyDown()
    - Aisikl has different methods to produce the same effects.
    - Cell editor keydown: TODO
    - Insert (to insert a new row): TODO
    - Ctrl+Delete (to delete a row): TODO
    - Enter (to start edit mode): IRRELEVANT, editing is synchronous.
    - Ctrl+A (to select everything): self.select([], inverted=True)
    - Ctrl+Up: self.up_down_row('UP') (onUpDownRow is TODO)
    - Ctrl+Down: self.up_down_row('DOWN') (onUpDownRow is TODO)
    - Home, End, PageUp, PageDown, arrows, etc: self.select(...)
- onTableContainerKeyPress()
    - IRRELEVANT
- onCtrlA() -> self.select([], inverted=True)
- movePage(), moveTop(), moveBottom()
    - UNSUPPORTED. See also getScrollBottomEnabled().
- scrollRowToVisible()
    - Reduces to TableService.onTableContainerScroll(), see above.
- getVisibleBuffersAsString(), getLoadedBuffersAsString()
    - Inlined in changed_properties().
- manageSelectionOnEvent()
    - Inlined in select().
- activateElement()
    - IRRELEVANT, even if it didn't start with "return;"
- eventOnRow(), eventOnCell()
    - Inlined in select(), along with manageSelectionOnEvent() and
      onDataTabSelectionChange().
    - The sendEditCell checkbox condition means that if we click a checkbox,
      selecting the row and toggling the checkbox at the same time, we never
      send both a selection event and a cell edited event (only the cell edited
      event). The checkbox is handled in eventOnCheckBox(), called from
      onDataTabClick(). In Votr, the selection event is prevented by the
      `_send_event` argument of select() when called from edit_cell().
- onDataTabClick()
    - Mainly calls eventOnCell(). Cell editor parts are IRRELEVANT, since we
      only support synchronous writing instead of an editing mode.
- onDataTabDblClick()
    - See Table.onDataTabDblClick().
- setCursorRow()
    - See TableService.setCursorRow().
- getStartBlockSelection()
    - IRRELEVANT (used to remember where we started Shift-selecting rows)
- selectCell(), selectRow(), unselect(), clearSelection()
    - Inlined into select(). See TableSelectionModel.
- selectCellByAlias()
    - IRRELEVANT. We don't have the DOM so we always select columns by alias.
- selectBlock()
    - IRRELEVANT. To select a range, use self.select(range(...)).
- updateStatusSelection()
    - IRRELEVANT
- getSelectedRowsAsString()
    - See TableSelectionModel.getSelectedRowsAsString().
- getSelectedRowIndexes() -> self.selected_row_indexes (we keep it sorted)
    - Or reversed(self.selected_row_indexes) depending on the argument.
- getRowTop()
    - IRRELEVANT
- getCellValue(), addCellValuesOfSelectedRows()
    - Sadly used in ValueInteractive. UNSUPPORTED for now.
- eventOnCheckBox()
    - self.edit_cell()
    - Combined with stopEditCell(). `in_checkbox` controls checkbox-specific
      behavior.
- addToChangedCells()
    - Changes self.changed_cells and self.last_changed_row_index. Inlined in
      self.edit_cell().
    - The addedByUser check TODO when we implement addRow() etc.
- getChangedCellsToXML()
    - Inlined in self.changed_properties()
    - addedRows and origId support is TODO when we implement addRow() etc.
- getLastChangedCellRowIndex()
    - self.last_changed_row_index
    - addedRows and origId support is TODO when we implement addRow() etc.
- resetChangedCellsAddedRows()
    - Inlined in self.changed_properties()
    - addedRows and origRowsCount are TODO when we implement addRow() etc.
- getCheckBoxFromCell(), getImageFromCell()
    - Sort of inlined in self._load_cell().
- getNewValue()
    - Inlined in self.changed_properties()
    - Technically, we should check presence of a checkbox instead of comparing
      editedBy to 'checkBox'. Instead, we set that value in self._load_cell().
    - origId support is TODO when we implement addRow() etc.
- onCellEditorDeactivate(), onCellEditorKeyDown(), onTextFieldEditKeyDown(),
  tryToAutoFocusNext(), onTextFieldButtonEditKeyDown()
    - IRRELEVANT
- onCellEditorClick()
    - See Table.onButtonNumCodeClick(). Otherwise IRRELEVANT.
- onComboBoxEditorFocus(), onComboBoxEditorBlur(), onComboBoxEditorChange(),
  onComboBoxEditorMouseDown(), onComboBoxEditorKeyDown(),
  onCheckBoxEditorMouseDown(), onCheckBoxEditorMouseOut(),
  onCheckBoxEditorClick(), prepareArrayForFindingCellToEdit(),
  moveCellEditorByTab(), startEditRow(), validateCellEditor()
    - IRRELEVANT
- startEditCell()
    - Mostly IRRELEVANT.
    - Note that you need to select the row/column you edit. This is done in
      self.edit_cell().
- stopEditCell()
    - self.edit_cell()
    - Combined with eventOnCheckBox(). `in_checkbox` controls checkbox-specific
      behavior.
    - The last argument of stopEditCell() was named `_skip_event`.
- startEditNewRow()
    - IRRELEVANT
- getInvertedSelection() -> self.inverted_selection
- switchSelectAll()
    - Inlined into select().
- onTableContainerContextMenu(), activateCellEditorOnFocus()
    - IRRELEVANT
- getRowsIds(), resetRowsIds(), moveRows(), upDown(), upDownRow(),
  upDownSelection(), addRow(), deleteRow()
    - TODO
- isRowEmpty(), cancelEvent(), destroy()
    - IRRELEVANT


# Table

Tables are the most complicated part of WebUI. Most other components were
directly written based on their JavaScript equivalents, removing DOM code and
replacing it with direct methods. For tables, the Aisikl code is much less
related to the original WebUI classes.

Some methods might not seem IRRELEVANT at first glance, but turn out to be only
used for positioning, colors and such. The JavaScript code went through multiple
passes, marking more and more methods as IRRELEVANT until it was manageable.

Several high-level simplifications have also been made:

First, we do not support full scrolling. WebUI tables are divided into buffers
and loaded one buffer at a time. The visible and loaded buffers can be arbitrary
intervals. Votr instead pretends the window is very high, so the set of visible
buffers is always an interval from 0 to n -- that is, the first buffer is always
visible.

Second, we ignore cell editing as much as possible. See CellEditor above.

Third, the various ways to select rows and cells with the mouse and keyboard
have been simplified. Users of Aisikl know the exact rows, and there's no reason
to select "the row below this one" (pressing down) etc.

Fourth, WebUI tables actually store all variable state twice (or more).
Selection state is stored once in Table and once split around the other classes,
mainly TableSelectionModel, along with some state only stored in the DOM. And
they are not the same. Table holds the latest server data, and the others hold
what the user sees. When the selection changes and an event is sent to the
server, it gives the new selection to Table, which in turn also updates it in
TableSelectionModel. We don't see any good reason for this, and so, Votr only
stores everything once, directly in Table.

- init() -> `__init__`
- ensureIframe()
    - IRRELEVANT
- initFromDataView() -> self._init_from_data_view()
    - Creating the iframe content is IRRELEVANT, but we still need to parse the
      data view scripts instead.
- initPropertiesAndModels()
    - Called from initTableModel() during iframe onload. Inlined into
      self._init_from_data_view().
- doesTableHaveModels() -> True
- deinitPropertiesAndModel(), destroy(), setWidth(), setHeight(),
  resizeComponent(), resizeChildren()
    - IRRELEVANT
- getSortable(), setSortable() -> self.sortable
- getAllwaysSelected(), setAllwaysSelected() -> self.always_selected
    - Note the extra ell in WebUI.
- getActiveRow(), setActiveRow()
    - UNSUPPORTED and possibly IRRELEVANT. getActiveRow() is only ever used in
      EventInteractive, and setActiveRow() is only ever called with the current
      cursorRowIndex. Probably can be replaced with that.
- getFixedColumns(), setFixedColumns() -> self.fixed_columns
- getMinNoFixedColumnsWidth(), setMinNoFixedColumnsWidth()
    - IRRELEVANT
- getUpDownEnabled(), setUpDownEnabled() -> self.up_down_enabled
- getReadOnly(), setReadOnly() -> self.read_only (inherited from Control)
- getUserAddRemoveRowsEnabled(), setUserAddRemoveRowsEnabled() ->
  self.user_add_remove_rows_enabled
- getSupportedEvents(), setSupportedEvents() -> self.supported_events
    - So much for usedListenersMask... sigh
- getMultipleSelection(), setMultipleSelection() -> self.multiple_selection
- getCellSelectionMode(), setCellSelectionMode() -> self.cell_selection_mode
    - This is whether you select a row (or multiple rows) or a single cell.
- getScrollBottomEnabled(), setScrollBottomEnabled() ->
  self.scroll_bottom_enabled
    - If true, you can send a request to move to the end even if the end isn't
      loaded yet. Uncommon and UNSUPPORTED, because we need a way to do that for
      all tables anyway.
- getSelectAllEnabled(), setSelectAllEnabled() -> self.select_all_enabled
    - If true, you can select all rows, which also counts as selecting rows that
      aren't loaded. In that case, the server actually receives a list of rows
      that *aren't* selected.
- realizeEnability(), getBorderWidth()
    - IRRELEVANT
- getRowNumbersVisible(), setRowNumbersVisible() -> self.row_numbers_visible
- setRowNumbersVisible_()
    - IRRELEVANT
- switchRowNumbersVisible() -> self.switch_row_numbers_visible()
- getStatusVisible(), setStatusVisible() -> self.status_visible
- switchStatusVisible() -> self.switch_status_visible()
- getVisibleStatusButtons(), setVisibleStatusButtons() ->
  self.visible_status_buttons
- getTruncatedDataMessage(), getLoadingDataMessage(), getNoDataLoadedMessage(),
  getSelectionColoringMode(), getSelectionCellsIncludingMode()
    - IRRELEVANT
- getIsEndOfData() -> self.is_end_of_data
- getTruncated() -> self.truncated
- getRowCount() -> self.row_count
- getDeclaredRowCount() -> self.declared_row_count
- getNoDataLoaded() -> self.no_data_loaded
- getLastTotalRowCount(), getLastScrollTop(), getLastFirstVisibleBuffer()
    - IRRELEVANT
- updateDataPositionProperties() -> self._update_data_position_properties()
- getSelection()
    - Removed (see Table overview). Use self.selected_row_indexes, which is a
      list of integers and corresponds to TableSelectionModel.rowSelection.
- getActiveIndex()
    - Removed (see Table overview). Use self.cursor_row_index, which corresponds
      to TableModel.cursorRowIndex.
- getInvertedSelection()
    - Removed (see Table overview). Use self.inverted_selection.
- getCellSelectionAlias()
    - Removed (see Table overview). Use self.selected_column_alias.
- setSelectionChanged(true) ->
  `self.selection_changed = True; self.dialog.component_changes(self, True)`
- setSelection()
    - Seems to be unused, and doesn't look like an AIS update function (it
      calls componentChanges etc). UNSUPPORTED until more is known.
- getSelectedOrEditedColumnAlias() -> self.selected_column_alias
- getDataSendType()
    - Used in updateSelection(), but only for scrolling.
    - dataSendType was changed into a local variable in updateData().
- getShowSelectionInUpdate()
    - Seems completely unused. IRRELEVANT.
- getBufferSize(), setBufferSize() -> self.buffer_size
- updateDataTabBodiesProperties() -> self._update_data_tab_bodies_properties()
    - dataSendType was changed into a local variable in _update_data()
    - showSelectionInUpdate is completely unused and thus IRRELEVANT
- getEditMode(), setEditMode()
    - Always False. Editing is instantaneous. See CellEditor above.
- updateSelectionModelProperties() -> self._update_selection_model_properties()
- getSelectedRowsCount() -> `len(self.selected_row_indexes)`
- getTableModelSelection()
    - See TableSelectionModel.getSelectedRowsAsString() above.
- getTableService(), getTableModel(), getTableHandler(), getSelectionModel()
    - IRRELEVANT
- onColumnHeaderResize() ->
  `self.headers_changed = True; self.dialog.component_changes(self, True)`
- onColumnMove() -> self.on_column_move() [TODO?]
- suspendPossibleEvents(), commitPossibleEvents()
    - IRRELEVANT, see EventManager above
- onDataTabSelectionChange()
    - Inlined into select() under "if selection_changed".
- onEditRow() -> self._on_edit_row()
    - Note that onEditRow() is unused in webui.js. EDITED_ROW is instead sent
      by onDataTabSelectionChange().
- sort() -> self.sort() [TODO?]
- switchSingleMultipleSelection() ->
  `self.dialog.try_interactive(self, "switchMultiple")`
- onScrollVerticaly() ->
  `self.scrolled_vertically = True; self.dialog.component_changes(self, True)`
    - Note the missing ell in WebUI.
- loadDataOnScrollUp()
    - IRRELEVANT, see Table overview.
- loadDataOnScrollDown()
    - Inlined in scroll_down(). -> self._load_data_on_scroll_down() [TODO?]
- loadDataOnScrollTop()
    - IRRELEVANT
- loadDataOnScrollBottom()
    - UNSUPPORTED, see getScrollBottomEnabled().
- onDataTabDblClick() -> self._on_data_tab_dbl_click() [TODO?]
- fireActionCommand() -> self._fire_action_command()
- onDataTabActiveIndexChange()
    - Inlined into select() under "if active_index_changed".
- deleteRow() -> self._delete_row() [TODO?]
- insertRow() -> self._insert_row() [TODO?]
- controlButtonRowCount() -> self._control_button_row_count() [TODO?]
- controlButtonColumns() -> self._control_button_columns() [TODO?]
- controlButtonSort() -> self._control_button_sort() [TODO?]
- controlButtonDebugInfo() -> self._control_button_debug_info() [TODO?]
, upDownRow() -> self.up_down_row()
- onUpDownRow() ->
  `self.up_downed_rows = True; self.dialog.component_changes(self, False)`
- onDeleteRow() ->
  `self.deleted_rows = True; self.dialog.component_changes(self, False)`
- onEditCell() -> self._on_edit_cell()
- onButtonNumCodeClick() -> self.button_num_code_click()
    - Combined with the preceding call to stopEditCell().
- canProcessEvent()
    - Is always True, because isMenuActivated() is IRRELEVANT.
- onScrollSpanKeyDown(), onScrollSpanKeyDownTryShortCut(), refocus(), focus(),
  onFocusIsInFrame(), isPreparedToBlur(), deactivateEdit(), onBodyMouseUp(),
  onBodyMouseDown(), onBodyClick(), onToolsButtonContextMenu(),
  menuItemAction(), onTableContainerContextMenu()
    - IRRELEVANT
- changedProperties() -> self.changed_properties()
- setDataView() -> self._ais_setDataView()
- updateData() -> self._update_data()
    - WebUI calls updateDataPositionProperties() in strange places. That's
      probably a bug. Votr calls it the same regardless of dataSendType.



# Synchronizer, ExpansionSynchronizer, CheckedSynchronizer

COMPLETE (inlined in Tree)

Synchronizer is stupidly implemented with strings instead of a
`map<string,bool>`, but otherwise it doesn't do much, so it's inlined in Tree.

- registerProPath(k)
    - if sync.get(k) == False: del sync[k]
    - elif sync.get(k) == None: sync[k] = True; return True
- registerConPath(k)
    - if sync.get(k) == True: del sync[k]
    - elif sync.get(k) == None: sync[k] = False; return True
- reset() -> `sync.clear()`
- remove(), add(), contains()
    - IRRELEVANT
    - Note that remove() has a bug: `remove("|a|b|c|", "a") == "b|c|"` which
      doesn't contain "|b|". (They chose the most inefficient way to do this,
      and even then, they still didn't get it right.)

ExpansionSynchronizer and CheckedSynchronizer are mostly the same:

- getExpandedPaths() -> `"|" + "|".join(k for k in sync if sync[k]) + "|"`
- getCollapsedPaths() -> `"|" + "|".join(k for k in sync if not sync[k]) + "|"`
- registerExpandedPath() / registerCheckedPath()
    - if registerProPath(k) then this.treeObject.onExpansionChanged(true)
    - Inlined in Tree.toggle_expansion() / Tree.toggle_checkbox().
- registerCollapsedPath() / registerUncheckedPath()
    - if registerConPath(k) then this.treeObject.onExpansionChanged(false)
    - Inlined in Tree.toggle_expansion() / Tree.toggle_checkbox().



# TreeModel

COMPLETE (merged into Tree)

The Votr version unifies the current selection, active path etc. into a single
source of truth, like with Table and TableModel.

- init()
    - IRRELEVANT, because updateSelection() and updateActivePath() are
      IRRELEVANT.
- resize(), doesTreeLookAsFocused(), ensureTreeLooksAndIsKnownAsFocused(),
  ensureTreeLooksAsBlured(), onBodyFocus(), onContainerFocus(),
  onContainerDeactivate(), onContainerMouseDown(), onContainerMouseUp(),
  onContainerClick(), onContainerDblClick(), onBodyContextMenu(),
  onBodyKeyDown(), onBodyKeyUp(), isEventOnNodeExpander(),
  onNodeExpanderMouseDown()
    - IRRELEVANT
- onNodeCheckBoxClick(), switchCheck() -> self.toggle_checkbox()
- findMyNode(), getNodeText(), getNodeImageElement(), getNodeExpanderImage()
    - IRRELEVANT
- isNodeExpanded() -> node.expanded
- getParentNode(), getChildrenNodes()
    - UNSUPPORTED (use the id)
- expandCollapse() -> self.toggle_expansion()
- getNodeOffsetTop()
    - IRRELEVANT
- onNodeDescriptionClick(), realizeSelectOnNode() -> self.select()
- repairSelectionAndActiveNodeOnCollapse()
    - IRRELEVANT (returns immediately in webui.js)
- setNodeActivity()
    - IRRELEVANT (only changes this.activeNode and does visual stuff)
    - Changing self.active_id is inlined in self.select()
- scrollOnActiveNode()
    - IRRELEVANT
- getFirstNode()
    - UNSUPPORTED
- findPreviousVisibleNode(), findNextVisibleNode(), moveCursor()
    - IRRELEVANT (aisikl can select nodes directly, without a "keyboard")
- getNodeImageElement()
    - IRRELEVANT
- clearSelection()
    - IRRELEVANT (webui only uses it right before selecting something else)
- recolorSelection(), updateNodeImageElement(), recolorNodeSelection()
    - IRRELEVANT
- isNodeSelected() -> `node in self.selected`
- getSelectionAsString()
    - Inlined in self.changed_properties()
- getSelectedNodesCount() -> `len(self.selected)`
- getActivePathAsString() -> `self.active_path[1:]`
- updateSelection(), updateActivePath()
    - IRRELEVANT, as Votr only has a single source of truth.
- update()
    - Merged with _init_from_data_view().
    - The "withChildren" attribute is UNSUPPORTED. Any nodeElement found in the
      update completely replaces its previous version.
- getSelectedNodeType() -> `self.nodes[self.selection[-1]].type`
- cancelEvent(), updateAriaProperty()
    - IRRELEVANT
- htmlId2path() -> `id[1:]`


# Tree

COMPLETE

- init() -> `__init__`
- initFromDataView() -> self._init_from_data_view()
    - Creating the iframe content is IRRELEVANT, but we still need to parse the
      data view scripts instead.
- resizeComponent(), resizeChildren()
    - IRRELEVANT
- initModel()
    - Previously called from initTreeModel() in iframe onload.
    - Inlined into _init_from_data_view().
- getTreeModel() -> self
- getExpansionSynchronizer() -> self.expansion_synchronizer
- getCheckedSynchronizer() -> self.checked_synchronizer
- deinitPropertiesAndModel()
    - IRRELEVANT
- onExpandCollapse(), onLoadChildren()
    - Inlined in self.toggle_expansion()
- setDataView() -> self._ais_setDataView()
- changedProperties() -> self.changed_properties()
- onSelectionChange()
    - Inlined in self.select()
- onExpansionChanged()
    - Inlined in registerExpandedPath() and registerCollapsedPath(), which are
      inlined in self.toggle_expansion().
- onCheckedChanged()
    - Inlined in registerCheckedPath() and registerUncheckedPath(), which are
      inlined in self.toggle_checkbox().
- onBodyDblClick() -> self.double_click()
- onBodyMouseDown(), onBodyMouseUp(), onBodyClick(), onBodyContextMenu(),
  onBodyKeyDown(), onBodyKeyUp(), realizeEnability(), refocus(), focus(),
  onFocusIsInFrame()
    - IRRELEVANT
- getMultipleSelection(), setMultipleSelection() -> self.multiple_selection
- getCommands(), setCommands() -> self.commands
- getBorderWidth() -> self.border_width
- getSelectedNodesCount() -> `len(self.selected)`



# MenuItem

COMPLETE

- getLid() -> self.lid
- realizeEnability(), realizeVisibility()
    - IRRELEVANT
- getRightArrowElement(), select(), unselect(), setClassName()
    - IRRELEVANT (visual only)
- isPopupTitle() -> `self.popup_menu_id != None`
- getPopupMenuId() -> self.popup_menu_id
- getTitle(), setTitle() -> self.title (`_ais_setTitle()` is inherited)
- getConfirmQuestion(), setConfirmQuestion() -> self.confirm_question
- getImage(), setImage() -> self.image
- onAction() -> self.click()
    - The single function argument was removed. It is true if this is an
      "internal" menu such as for split panes, tabbed panes or tables, and
      controls whether to call menuItemAction(). This is IRRELEVANT.
    - A new argument was added. Because votr doesn't have a PopupMenuManager,
      params can be given directly to MenuItem.click().



# PopupMenu

COMPLETE

Votr doesn't keep track of which PopupMenus are open, or what item is selected.
The user can just access the wanted MenuItem directly in dialog.components,
there's no need to simulate opening the right menu first.

Some menus emit an "init" event when opened or an "beforeclose" event when
closed. Votr supports that, but you have to do it manually.

- setIsInternal(), getIsInternal()
    - IRRELEVANT. Votr doesn't handle internal popup menus.
- selectedItemJSObject, hasVisibleItems(), focus(), showAsSubpopup(), doShow(),
  showHideSeparators(), getSelectedItemJSObject(), setSelectedItemJSObject(),
  isVisible(), resizeComponent(), realizeEnability(), realizeVisibility()
    - IRRELEVANT
- show() -> self.show()
- hide() -> self.hide()
- getMenuItem() -> `self.dialog.components[id]`
- setComponents()
    - UNSUPPORTED. Dynamically adding and removing components? No thanks.



# PopupMenuManager

IRRELEVANT

See PopupMenu above.

Note that PopupMenuManager.showPopupMenus() might receive non-null params and
store them in the PopupMenuManager. (This currently only happens when called
from tryShowPopupMenuFromHtmlArea() through HtmlArea.bodyContextMenu().) Votr
doesn't want to store "the params value for the currently open menu", so the
user must give params directly to MenuItem.click() instead.



# Interactive, EventInteractive, ValueInteractive, ChangeGuardInteractive

TODO



# WebUI

PARTIAL

Mostly covered by Application. No longer global.

- fillResultFrame()
    - Called from `request.html` (the request frame). Roughly corresponds to
      Application._process_response().
- appId -> app.app_id
- appContext -> "ais"
- webuiContext -> "ais/webui2"
- getAppBody(), getRequestFrame(), getResultFrame(), getDownloadFrame(),
  getLogFrame(), getDisableDialogsGlass(), webuiVersion, useAria
    - IRRELEVANT
- getHost(), getPort(), getProtocol() -> context.ais_url
- webuiVersion, useAria
    - IRRELEVANT
- controlerUrl -> "/ais/servlets/WebUIServlet" (currently hardcoded)
- initializedByRefresh -> False (because initScript is UNSUPPORTED)
- windowInFrame, isWindowInFrame(), isWindowInModalWindow() -> False
    - UNSUPPORTED until we actually see it in use.
- windowFrameAccessible, isWindowFrameAccessible() -> True
    - UNSUPPORTED until we actually see it in use.
- getWindowFrame() -> None
    - Because isWindowInFrame() is False.
- refreshAppEnabled -> False
    - Because windowInFrame is False.
- timeDifference
    - IRRELEVANT
- noteLastDoneRequest(), lastDoneRequest
    - IRRELEVANT (probably related to retrying failed requests)
- historyBack() -> no-op
- initApplication() -> app._open()
    - Non-empty initScript is UNSUPPORTED.
- initScriptDialogsDataView, getInitScriptDialogContent()
    - UNSUPPORTED, because non-empty initScript is UNSUPPORTED.
- startRestoreConnectionCountdown(), stopRestoringConnection()
    - TODO (IRRELEVANT?)
- wasKilled
    - IRRELEVANT. Mainly used in WebUI to ensure clear() only runs once.
- wasWindowClose
    - IRRELEVANT. Only used to ensure window.close() is only called once.
- wasClosedOnServer, serverCloseApplication()
    - See clear() below. The serverCloseApplication() operation usually requires
      no reaction, and is handled in Application.awaited_close_application().
- closeApplication()
    - Equivalent to clear(true) followed by window.close().
    - The withBrowser argument is only used if NativeDialog_getOpenedDialog(),
      and even then, it only delays closeApplication() until the dialog closes.
- beforeUnload(), unload()
    - IRRELEVANT
- clear()
    - The main method for closing the application. WebUI calls in
      closeApplication() (an operation used in result frame scripts), in
      onAppClosedOnServer(), and after closing the last dialog.
    - If wasClosedOnServer is false (i.e. serverCloseApplication() was not
      called) and the withRequest argument is true, clear() sends
      a WebUIKillEvent and ignores the response. In Votr, this is done with
      Application.force_close().
    - Afterwards, clear() sets various things to null (probably trying to avoid
      memory leaks in old IE) and closes the window. Votr doesn't need that.
      The program can access the Application object even after it's closed, but
      sending any requests would cause an AISApplicationClosedError.
    - Usually, pressing the close or exit button in the last dialog results in
      serverCloseApplication(), closeDialog(), and closeApplication(). That
      means clear() just closes the window without sending any requests. In
      Votr, this is handled by Application.awaited_close_application().
    - Normally, WebUIKillEvent is never sent. It would only be sent e.g. if the
      server called closeDialog() but not serverCloseApplication(). But the
      event is useful for Votr, because it can close an application regardless
      of its current state or the open dialogs.
- onAppClosedOnServer()
    - Shows an alert and calls clear(false), which basically closes the window
      without sending any requests.
    - In Votr, this is handled in parse_response() by raising
      AISApplicationClosedError. No other cleanup (closing dialog etc) is done.
- setReturnValue()
    - UNSUPPORTED
- sendingEvent, getSendingEvent(), setSendingEvent()
    - IRRELEVANT (everything is synchronous)
- sendEvent()
    - Covered by app.send_events(*events)
    - `<ev>` is constructed in Event, including `<origSrcName>`.
- sendRequest(), _sendRequest()
    - Merged, because everything in Votr is synchronous.
    - Calls to sendRequest() can be mostly replaced with app._do_request().
    - Application._send_request() composes and sends the request, while
      Application._process_response() processes the result frame.
- updateStartTime, previousResponseProcessingTime
    - UNSUPPORTED
- sendFileUploadSubmit()
    - TODO
- onSomeDialogBodyInitialized()
    - IRRELEVANT, because everything is synchronous, so requests never have to
      wait until some dialog is loaded.
- sendWhatsUp(), whatsUpGetLastOutput(), whatsUpGetLastRequest(),
  startWhatsUpTimer(), setIdleEventInterval(), getPingOrIdleInterval()
    - TODO
- sendEmptyRequest() -> app.send_empty_request()
- currentTimeMillis() -> time.time()
    - Used only in `antiCache`, so nobody cares whether it's a float.
- prepareUpdatingDialogs()
    - IRRELEVANT
- popupMenuToShowAfterEnableJSO, setPopupMenuToShowAfterEnable()
    - IRRELEVANT, because Votr is synchronous, and PopupMenuManager is removed.
- isDisabledApplication(), disableApplication(), enableApplication()
    - IRRELEVANT. An Application is disabled when _do_request is on the stack.
- showDisableDialogsGlass(), refreshDisableDialogsGlass(),
  showHideOneDisableDialogsGlass(), showHideMultiDisableDialogsGlass(),
  prepareGlasses(), resizeGlass(), createGlass()
    - IRRELEVANT
- panicMode()
    - IRRELEVANT
    - No need to implement it. We will throw because it's not in
      known_operations.
- changesToXML(), resetComponentChanges()
    - Merged into Application.collect_component_changes()
- onComponentChanges()
    - Merged into Dialog.component_changes(), because Dialog.componentChanges()
      was the only caller.
    - Webui uses an array of tuples instead of a normal hash table. In essence,
      we want a list of changed dialogs, and for each dialog, a set of changed
      components. Our Dialog simply uses a set().
    - `value` is completely unused. `propertyName` is almost unused, except
      that most properties set hasRefreshImportantChange to true, and a few
      don't. hasRefreshImportantChange is almost useless, so we just say it's
      always true, and remove both `propertyName` and `value` arguments.
- isRegisteredComponentChange(), getAppReferrer()
    - IRRELEVANT (unused in webui)
- hasRefreshImportantChanges() -> True
    - See onComponentChanges() above. Only used in clear().
- messageBox(), confirmBox(), fileUpload(), fileXUpload(), editDoc(),
  abortBox(), shellExec(), showHelp(), startApp()
    - Listed in known_operations.
    - Specific support (especially sending proper responses) is TODO.
- abort()
    - IRRELEVANT. Votr is synchronous, so a request can't be aborted.
- sendSuggestionsRequest(), sendSuggestionsRequest_()
    - Suggestions are UNSUPPORTED
- setShellExecResult(), initCustomFrame(), setCustomFrameWindow()
    - UNSUPPORTED
- dblClick(), keyDown(), updateAppSizeProperties(), workspaceResize(),
  setUpdateInterval(), getScrollBarWidth(), setWidth(), setHeight(),
  resizeBrowserByApp(), cancelEvent(), getSrcElement()
    - IRRELEVANT
- sendPostMessage()
    - UNSUPPORTED
- readCustomization(), getProperty(), getPropertyAsBoolean(),
  getPropertyAsInt()
    - Wasn't needed yet, except for reading initScript in Application._open(),
      which is hardcoded. controlerUrl and downloadContext is also hardcoded.
- WebUI_init
    - Parsed in Application._open()
- killApplication()
    - IRRELEVANT. Calls window.close().
    - Also called from the portal window just before logout.


